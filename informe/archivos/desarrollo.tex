\section{Desarrollo}
% Deben explicarse los metodos numericos que utilizaron y su aplicacion al
% problema concreto involucrado en el trabajo practico. Se deben mencionar los
% pasos que si- guieron para implementar los algoritmos, las dicultades que
% fueron encontrando y la descripcion de como las fueron resolviendo. Explicar
% tambien como fueron planteadas y realizadas las mediciones experimentales.
% Los ensayos fallidos, hipotesis y conjeturas equivocadas, experimentos y
% metodos malogrados deben gurar en esta seccion, con una breve explicacion
% de los motivos de estas fallas (en caso de ser conocidas)

\subsection{Implementación de la matriz}

\subsubsection{Estructura}

Para almacenar la matriz usamos arrays los cuales sólo tenían valores válidos en las posiciones que correspondían con el número de fila representada. Es decir dada una fila-$i$, ésta sólo está seteada en las posiciones $i - p$ a $i + q + p$. Si quisiéramos acceder a posiciones por fuera de ese rango obtendríamos valores inválidos.\\

Para poder indexar la matriz usamos macros de \verb|C| los cuáles dado los offsets de 0's nos permitió acceder a la posición de la matriz que nos interesaba.

\subsubsection{Llenado}

Dada la numeración de los links y el planteo de la matriz, se nos ocurrió hacer un estudio de las juntas para ver qué fuerzas interactuaban con cada una. Es decir, a partir de la estructura de la matriz, pensamos conveniente hacer una caracterización de las ecuaciones ya que vimos que los patrones se repetían.\\

Nos quedaron en total 20 casos, que si bien fue tedioso tener que escribir el código para cada uno de los casos, nos pareció mas fácil de implementar y de $debuggear$ que el haber hecho un ciclo y llenarlo de $if's$ para cada caso.

\subsection{Triangulación}

Usamos Gauss con pivoteo parcial para poder triangular la matriz. Gracias a la implementación de nuestra matriz, el algoritmo resultó bastante estándar. Por la naturaleza de Gauss y sabiendo que la matriz es banda $p$, $q + p$ solo accedimos a esas posiciones relevantes, sobreentendiendo que los posiciones fuera de ese rango son $0$.

\subsection{Heurística}

Veamos primero el pseudocódigo de lo que hicimos y luego explicaremos brevemente su motivación.
\begin{verbatim}
def heuristica(m, begin, end, n):

    costo, f_max = calc_costo_fuerza(m, begin, end)

    if n == 2:
        return costo, None
    else:
        cost1, pilares = heuristica(m, 0, mitad(n))
        cost2, pilares2 = heuristica(m, mitad(n), n)
        costo_heuristica = cost1 + cost2 + costo_pilar

    // Si se rompe o sale más barato dividir
    if f_max > f_limite or (cost1 + cost2 + costo_pilar < costo):
        poner_pilar(n/2)
        return costo_heuristica, (pilares + pilares2 + pilar[n/2])
    else:
        return (costo, None)
                        
def calc_costo_fuerza(m, inicio, fin)
    // Esta función devuelve el costo total del
    // subpuente y el valor de la máxima fuerza
    return costo, f_max
\end{verbatim}

Nuestro enfoque para encarar este problema puede catalogarse como una técnica de $Divide$ $\&$ $Conquer$, en la cual nos fijamos primero si el puente colapsa, si colapsa se coloca un pilar en la junta central y se llama recursivamente a la función con los dos nuevos subpuentes, esto también se aplica si el puente no se colapsa pero el costo de colocar un pilar el medio es menor que el costo actual.

Los casos base serían cuando las secciones son sólo 2 y cuando el costo de colocar un pilar supera al costo actual.
