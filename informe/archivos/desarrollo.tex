\section{Desarrollo}
% Deben explicarse los metodos numericos que utilizaron y su aplicacion al
% problema concreto involucrado en el trabajo practico. Se deben mencionar los
% pasos que si- guieron para implementar los algoritmos, las dicultades que
% fueron encontrando y la descripcion de como las fueron resolviendo. Explicar
% tambien como fueron planteadas y realizadas las mediciones experimentales.
% Los ensayos fallidos, hipotesis y conjeturas equivocadas, experimentos y
% metodos malogrados deben gurar en esta seccion, con una breve explicacion
% de los motivos de estas fallas (en caso de ser conocidas)

\subsection{Implementación de la matriz}

\subsubsection{Estructura}

Para almacenar la matriz usamos arrays los cuales sólo tenían valores válidos en las posiciones que correspondían con el número de fila representada. Es decir dada una fila-$i$, ésta sólo está seteada en las posiciones $i - p$ a $i + q + p$. Si quisiéramos acceder a posiciones por fuera de ese rango obtendríamos valores inválidos.\\

Para poder indexar la matriz usamos macros de \verb|C| los cuáles dado los offsets de 0's nos permitió acceder a la posición de la matriz que nos interesaba.

\subsubsection{Llenado}

Dada la numeración de los links y el planteo de la matriz, se nos ocurrió hacer un estudio de las juntas para ver qué fuerzas interactuaban con cada una. Es decir, a partir de la estructura de la matriz, pensamos conveniente hacer una caracterización de las ecuaciones ya que vimos que los patrones se repetían.\\

Nos quedaron en total 20 casos, que si bien fue tedioso tener que escribir el código para cada uno de los casos, nos pareció mas fácil de implementar y de $debuggear$ que el haber hecho un ciclo y llenarlo de $if's$ para cada caso.

\subsection{Triangulación}

Usamos Gauss con pivoteo parcial para poder triangular la matriz. Gracias a la implementación de nuestra matriz, el algoritmo resultó bastante estándar. Por la naturaleza de Gauss y sabiendo que la matriz es banda $p$, $q + p$ sólo accedimos a esas posiciones relevantes, sobreentendiendo que los posiciones fuera de ese rango son $0$.

 \subsection{Prototipo y metodología de desarrollo}

Considerando la complejidad de implementación inicial del código en un lenguaje de bajo nivel, desarrollamos un prototipo inicial en \textit{Python}, utilizando las librerias de \textit{NumPy}, y posteriormente \textit{Matplotlib} para la realización de gráficos de los experimentos.\\

Primero que nada escribimos el código correspondiente a la caracterización de los links, fuerzas, y juntas del puente, correspondiendo a los distintos lugares de la matriz que resuelve las ecuaciones de fuerza. Luego puedimos corroborar que dicha caracterización era correcta usando como casos de pruebas los ejemplos provistos por la cátedra, y aprovechando el \textit{solver} de ecuaciones matriciales provisto por \textit{NumPy}, previo a desarrollar el resto del problema.\\

En paralelo, desarrollamos una implementación de matriz diagonal esparsa en \textit{C++}. La misma está implementada internamente como una matriz de $ancho = p + q$, donde todos los accesos a los elementos de la misma se dan por las macros \textit{eq(joint, axis)} y \textit{f(force)}.\\

La primera devuelve la fila de matriz correspondiente a la ecuación para la junta \textit{joint} en el eje \textit{x} o \textit{y}.La segunda devuelve la posición en la matriz a la que corresponde el número de fuerza dado según nuestro esquema de numeración.\\

Una vez verificados el correcto funcionamiento de la matriz esparsa y la caracterización de las fuerzas, desarrollamos el código correspondiente a la triangulación y \textit{backward substitution} para ser probado en casos de prueba, en los que retorna las fuerzas de cada link.\\

A partir de ahí desarrollamos una \textit{suite} de pruebas en \textit{Python} para realizar los experimentos presentados en la siguiente sección. Finalmente, agregamos el código correspondiente a la heurística y la capacidad de generar un puente a partir de un archivo de entrada.


